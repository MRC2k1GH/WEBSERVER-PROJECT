input {
  beats {
    port => 5044
  }
}

filter {
  if [fields][log_type] == "apache_access" {
    grok {
      match => { "message" => "%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:response} %{NUMBER:bytes} \"%{DATA:referrer}\" \"%{DATA:useragent}\"" }
    }
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
    geoip {
      source => "clientip"
      target => "[client][geo]"
    }
    useragent {
      source => "useragent"
      target => "user_agent"
    }
    mutate {
      add_field => { "log_type" => "apache_access" }
    }
  }
  else if [fields][log_type] == "apache_error" {
    grok {
      match => { "message" => "\[%{DAY:day} %{MONTH:month} %{MONTHDAY:monthday} %{TIME:time} %{YEAR:year}\] \[%{DATA:module}:%{LOGLEVEL:level}\] \[pid %{NUMBER:pid}:tid %{NUMBER:tid}\] %{GREEDYDATA:error_message}" }
    }
    mutate {
      add_field => { "temp_timestamp" => "%{day} %{month} %{monthday} %{time} %{year}" }
    }
    date {
      match => [ "temp_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      target => "@timestamp"
    }
    mutate {
      remove_field => ["temp_timestamp", "day", "month", "monthday", "time", "year"]
    }
    if [error_message] =~ /AH\d+:/ {
      grok {
        match => { "error_message" => "AH%{NUMBER:error_code}: %{GREEDYDATA:error_description}" }
      }
    }
    mutate {
      add_field => { "log_type" => "apache_error" }
    }
  }
  else if [fields][log_type] == "mysql_error" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{NUMBER:thread_id} \[%{LOGLEVEL:level}\] %{GREEDYDATA:error_message}" }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    mutate {
      add_field => { "log_type" => "mysql_error" }
    }
  }
  else if [fields][log_type] == "mysql_slow" {
    grok {
      match => { "message" => "# Time: %{TIMESTAMP_ISO8601:timestamp}\n# User@Host: %{DATA:user_host}\n# Query_time: %{NUMBER:query_time} Lock_time: %{NUMBER:lock_time} Rows_sent: %{NUMBER:rows_sent} Rows_examined: %{NUMBER:rows_examined}\n%{GREEDYDATA:sql_query}" }
    }
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    mutate {
      add_field => { "log_type" => "mysql_slow" }
    }
  }
  else if ![log_type] and ![fields][log_type] {
    if [message] =~ /^\d+\.\d+\.\d+\.\d+.*\[.*\].*HTTP/ {
      grok {
        match => { "message" => "%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:verb} %{GREEDYDATA:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:response} %{NUMBER:bytes} \"%{DATA:referrer}\" \"%{GREEDYDATA:useragent}\"" }
        tag_on_failure => ["_grokparsefailure_apache_access_fallback"]
      }
      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      }
      geoip {
        source => "clientip"
        target => "[client][geo]"
      }
      useragent {
        source => "useragent"
        target => "user_agent"
      }
      mutate {
        add_field => { "log_type" => "apache_access" }
      }
    }
    else if [message] =~ /^\[.*\].*\[.*\].*\[pid.*tid.*\]/ {
      grok {
        match => { "message" => "\[%{DAY:day} %{MONTH:month} %{MONTHDAY:monthday} %{TIME:time} %{YEAR:year}\] \[%{DATA:module}:%{LOGLEVEL:level}\] \[pid %{NUMBER:pid}:tid %{NUMBER:tid}\] %{GREEDYDATA:error_message}" }
        tag_on_failure => ["_grokparsefailure_apache_error_fallback"]
      }
      mutate {
        add_field => { "temp_timestamp" => "%{day} %{month} %{monthday} %{time} %{year}" }
      }
      date {
        match => [ "temp_timestamp", "EEE MMM dd HH:mm:ss yyyy" ]
      }
      mutate {
        remove_field => ["temp_timestamp", "day", "month", "monthday", "time", "year"]
      }
      mutate {
        add_field => { "log_type" => "apache_error" }
      }
    }
    else if [message] =~ /^\d{4}-\d{2}-\d{2}T.*\d+ \[.*\]/ {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{NUMBER:thread_id} \[%{LOGLEVEL:level}\] %{GREEDYDATA:error_message}" }
        tag_on_failure => ["_grokparsefailure_mysql_error_fallback"]
      }
      date {
        match => [ "timestamp", "ISO8601" ]
      }
      mutate {
        add_field => { "log_type" => "mysql_error" }
      }
    }
  }

  mutate {
    remove_field => ["@version", "agent", "ecs", "input", "host", "tags"]
  }
}

output {
  elasticsearch {
    hosts => ["https://elasticsearch:9200"]
    user => "logstash_writer"
    password => "password"
    cacert => "/usr/share/logstash/config/certs/ca.crt"
    index => "logstash"
  }
  stdout {
    codec => rubydebug
  }
}